package vsolver

import (
	"crypto/sha256"
	"sort"
)

// HashInputs computes a hash digest of all data in a SolveOpts that are as
// function inputs to Solve().
//
// The digest returned from this function is the same as the digest that would
// be included with a Solve() Result. As such, it's appropriate for comparison
// against the digest stored in a lock file, generated by a previous Solve(): if
// the digests match, then manifest and lock are in sync, and a Solve() is
// unnecessary.
//
// (Basically, this is for memoization.)
func (o SolveOpts) HashInputs() []byte {
	d, dd := o.M.GetDependencies(), o.M.GetDevDependencies()
	p := make(sortedDeps, len(d))
	copy(p, d)
	p = append(p, dd...)

	sort.Stable(p)

	h := sha256.New()
	for _, pd := range p {
		h.Write([]byte(pd.Ident.LocalName))
		h.Write([]byte(pd.Ident.NetworkName))
		h.Write([]byte(pd.Constraint.String()))
	}

	// The stdlib packages play the same functional role in solving as ignores.
	// Because they change, albeit quite infrequently, we have to include them
	// in the hash.
	h.Write([]byte(stdlibPkgs))

	// TODO deal with an err here
	// TODO encap within bridge
	ptree, _ := listPackages(o.Root, string(o.N))
	for _, perr := range ptree.Packages {
		if perr.Err != nil {
			h.Write([]byte(perr.Err.Error()))
		} else {
			h.Write([]byte(perr.P.Name))
			h.Write([]byte(perr.P.CommentPath))
			h.Write([]byte(perr.P.ImportPath))
			for _, imp := range perr.P.Imports {
				h.Write([]byte(imp))
			}
			for _, imp := range perr.P.TestImports {
				h.Write([]byte(imp))
			}
		}
	}

	// TODO overrides
	// TODO aliases
	// TODO ignores
	return h.Sum(nil)
}

type sortedDeps []ProjectDep

func (s sortedDeps) Len() int {
	return len(s)
}

func (s sortedDeps) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (s sortedDeps) Less(i, j int) bool {
	return s[i].Ident.less(s[j].Ident)
}
